<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LOLBeans Programmatic Object Simulator V5 (å‹•ä½œä¿è¨¼ç‰ˆ)</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 20px;
            background-color: #f4f7f6;
            color: #333;
        }
        .container {
            display: flex;
            gap: 20px;
            max-width: 1200px;
            margin: auto;
        }
        .controls, .simulation {
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            background-color: #fff;
        }
        .controls {
            flex: 1;
            min-width: 350px;
        }
        .simulation {
            flex: 2;
            min-height: 400px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
            border: 2px solid #5D54A4;
            perspective: 800px; 
        }
        h1 { color: #5D54A4; }
        h2 {
            color: #5D54A4;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 10px;
            margin-top: 0;
        }
        label {
            display: block;
            margin-top: 15px;
            font-weight: bold;
            color: #444;
        }
        select, input[type="number"] {
            width: 100%;
            padding: 10px;
            margin-top: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
        }
        #formula-output {
            background-color: #eee;
            padding: 15px;
            border-radius: 4px;
            white-space: pre-wrap;
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 14px;
            margin-top: 15px;
            border-left: 5px solid #007bff;
            word-break: break-all;
            min-height: 100px;
        }
        #sim-object {
            width: 80px; 
            height: 80px;
            background-color: #ff6f61;
            border-radius: 8px; 
            position: absolute;
            top: 50%;
            left: 50%;
            transform-style: preserve-3d; 
            /* åˆæœŸå‚¾ã: Yè»¸ã¯CSSã§å›ºå®šã—ã€3Då›è»¢ã®è¦–èªæ€§ã‚’é«˜ã‚ã‚‹ */
            transform: translate(-50%, -50%) rotateX(-15deg) rotateY(15deg); 
            will-change: transform;
            transition: background-color 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            border: 3px solid #e91e63;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
        }
        .param-group {
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid #eee;
            border-radius: 4px;
        }
        .hidden {
            display: none !important;
        }
        .axis-info {
            position: absolute;
            top: 5px;
            left: 5px;
            font-size: 12px;
            color: #aaa;
        }
        #axis-selector label {
            display: inline-block;
            margin-right: 15px;
            font-weight: normal;
        }
    </style>
</head>
<body>

    <h1>LOLBeans Programmatic Object ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ (å‹•ä½œä¿è¨¼ç‰ˆ)</h1>
    <p>æ•°å¼ã‚’è¨­å®šã—ãŸã„**è»¸ã‚’è¤‡æ•°é¸æŠ**ã—ã€ãƒ—ãƒªã‚»ãƒƒãƒˆã‚„ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’èª¿æ•´ã—ã¦å‹•ãã‚’ç¢ºèªã§ãã¾ã™ã€‚</p>

    <div class="container">
        <div class="controls">
            <h2>è¨­å®šã¨ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿</h2>

            <div class="param-group">
                <label>é©ç”¨ã™ã‚‹è»¸ã®é¸æŠ (è¤‡æ•°é¸æŠå¯):</label>
                <div id="axis-selector">
                    <label><input type="checkbox" name="axis" value="positionX"> PositionX</label>
                    <label><input type="checkbox" name="axis" value="positionY"> PositionY</label>
                    <label><input type="checkbox" name="axis" value="positionZ" checked> PositionZ</label>
                    <label><input type="checkbox" name="axis" value="rotationX"> RotationX</label>
                    <label><input type="checkbox" name="axis" value="rotationY"> RotationY</label>
                    <label><input type="checkbox" name="axis" value="rotationZ"> RotationZ</label>
                </div>
            </div>

            <label for="preset">ãƒ—ãƒªã‚»ãƒƒãƒˆã®é¸æŠ:</label>
            <select id="preset">
                <option value="straight_line_ease">å¾€å¾©ç§»å‹• (easeInOutQuad)</option>
                <option value="circular_motion_xz">å¿œç”¨: æ°´å¹³é¢ (X-Z) å††é‹å‹•</option>
                <option value="swing">ã‚¹ã‚¤ãƒ³ã‚° (sinæ³¢)</option>
                <option value="rotation">ä¸€å®šé€Ÿåº¦ã®å›è»¢</option>
                <option value="straight_line">ç›´ç·šç§»å‹• (ãƒ«ãƒ¼ãƒ—)</option>
                <option value="linear_acceleration_cap">ç·šå½¢åŠ é€Ÿ (é€Ÿåº¦ä¸Šé™ã‚ã‚Š)</option>
            </select>

            <div class="param-group">
                <label for="duration">Loop Duration (duration) / å‘¨æœŸ (ç§’):</label>
                <input type="number" id="duration" value="5" min="0.1" step="0.1">
            </div>
            
            <div id="movement-params" class="param-group">
                <label for="distance">è·é›¢ / åŠå¾„ (Distance/Radius):</label>
                <input type="number" id="distance" value="100" min="1" step="10">
            </div>

            <div id="rotation-params" class="param-group hidden">
                <label for="amplitude">æŒ¯å¹… / å›è»¢é€Ÿåº¦ (Amplitude/Speed):</label>
                <input type="number" id="amplitude" value="45" min="1" step="1">
                <small>ã‚¹ã‚¤ãƒ³ã‚°: æŒ¯å¹…(Â°) / å›è»¢: é€Ÿåº¦(Â°/s)</small>
            </div>

            <label>ç”Ÿæˆã•ã‚ŒãŸæ•°å¼ (é¸æŠã•ã‚ŒãŸè»¸åˆ†):</label>
            <pre id="formula-output"></pre>
        </div>

        <div class="simulation">
            <h2>ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒªã‚¢</h2>
            <div class="axis-info">PositionX: å·¦å³ | PositionZ: å¥¥æ‰‹å‰ï¼ˆå¥¥è¡Œãï¼‰| Rotation: 3Då›è»¢</div>
            <div id="sim-object">OBJ</div>
        </div>
    </div>

    <script>
        const PI = Math.PI;
        
        // ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å†…ã®åˆæœŸåº§æ¨™ï¼ˆç›¸å¯¾ä½ç½®ï¼‰
        const START_POS_X = 0;
        const START_POS_Y = 0;
        const START_POS_Z = 0;
        const START_ROT_X = 0;
        const START_ROT_Y = 0;
        const START_ROT_Z = 0;
        
        // åˆæœŸå‚¾ã (CSSã¨åˆã‚ã›ã¦ã€3Då›è»¢ã®è¦–èªæ€§ã‚’é«˜ã‚ã‚‹)
        const INITIAL_ROT_X = -15; 
        const INITIAL_ROT_Y = 15;

        // DOMè¦ç´ 
        const presetSelect = document.getElementById('preset');
        const durationInput = document.getElementById('duration');
        const distanceInput = document.getElementById('distance');
        const amplitudeInput = document.getElementById('amplitude');
        const formulaOutput = document.getElementById('formula-output');
        const simObject = document.getElementById('sim-object');
        const axisCheckboxes = document.querySelectorAll('#axis-selector input[type="checkbox"]');
        
        let startTime = null;
        let animationFrameId;

        /**
         * LOLBeansã®æ•°å¼ã‚’è©•ä¾¡ã™ã‚‹ï¼ˆå¼·åŒ–ç‰ˆï¼‰
         */
        const safe_evaluate = (formula, context) => {
            const { time, duration, startPositionX, startPositionY, startPositionZ, startRotationX, startRotationY, startRotationZ } = context;
            const sin = Math.sin;
            const cos = Math.cos;
            const pow = Math.pow;
            const abs = Math.abs;
            const PI = Math.PI;
            
            // ãƒ¦ãƒ¼ã‚¶ãƒ¼å®šç¾©å¤‰æ•°ã‚’ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã«å®£è¨€
            let t, step1, step2, step3, a, v0, radius; 

            try {
                let code = formula.trim();
                let lines = code.split(';').map(line => line.trim()).filter(line => line.length > 0);
                if (lines.length === 0) return null; 
                
                let finalLine = lines.pop();
                let fullCode = lines.join('; ') + (lines.length > 0 ? ';' : '') + ` return (${finalLine});`;

                // evalã‚’ä½¿ã£ã¦ã€æ•°å¼å†…ã®å¤‰æ•°å®šç¾©ã¨è¨ˆç®—ã‚’åŒã˜ã‚¹ã‚³ãƒ¼ãƒ—ã§å®Ÿè¡Œ
                // å®‰å…¨æ€§ã®ãŸã‚ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‹ã‚‰ã®å…¥åŠ›ï¼ˆformulaï¼‰ã«ã®ã¿ä½¿ç”¨
                return eval(fullCode); 

            } catch (e) {
                // ã‚¨ãƒ©ãƒ¼æ™‚ã¯åˆæœŸå€¤ã‚’è¿”ã™
                const axis = formula.includes("position") ? formula.match(/position[XYZ]/) : (formula.includes("rotation") ? formula.match(/rotation[XYZ]/) : null);
                const axisStr = axis ? axis[0] : '';

                if (axisStr === 'positionX') return startPositionX;
                if (axisStr === 'positionY') return startPositionY;
                if (axisStr === 'positionZ') return startPositionZ;
                if (axisStr === 'rotationX') return startRotationX;
                if (axisStr === 'rotationY') return startRotationY;
                if (axisStr === 'rotationZ') return startRotationZ;
                return 0; 
            }
        };


        /**
         * ãƒ—ãƒªã‚»ãƒƒãƒˆã¨è»¸ã®é¸æŠã«åŸºã¥ã„ã¦æ•°å¼ã‚’ç”Ÿæˆã—ã€UIã‚’æ›´æ–°ã™ã‚‹
         */
        function updateFormula() {
            const selectedAxes = Array.from(axisCheckboxes).filter(cb => cb.checked).map(cb => cb.value);
            const preset = presetSelect.value;
            // duration, distance, amplitude ã¯ã“ã“ã§ã¯å†åˆ©ç”¨ã™ã‚‹ãŸã‚ã€constå®£è¨€
            const duration = parseFloat(durationInput.value) || 1;
            const valueA = parseFloat(distanceInput.value) || 100; // ç§»å‹•é‡/åŠå¾„
            const valueB = parseFloat(amplitudeInput.value) || 45; // æŒ¯å¹…/é€Ÿåº¦

            let outputFormula = '';
            let targetProperties = [];

            // ãƒ—ãƒªã‚»ãƒƒãƒˆã«ã‚ˆã‚‹è»¸ã®å¼·åˆ¶é¸æŠãƒã‚§ãƒƒã‚¯
            if (preset === 'circular_motion_xz' && (!selectedAxes.includes('positionX') || !selectedAxes.includes('positionZ'))) {
                 outputFormula = "// å††é‹å‹•ã«ã¯ PositionX ã¨ PositionZ ã®ä¸¡æ–¹ã®è¨­å®šãŒå¿…è¦ã§ã™ã€‚è»¸ã‚’é¸æŠã—ç›´ã™ã‹ã€ä»–ã®ãƒ—ãƒªã‚»ãƒƒãƒˆã‚’é¸ã‚“ã§ãã ã•ã„ã€‚";
                 formulaOutput.textContent = outputFormula;
                 // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’åœæ­¢ã•ã›ã‚‹ (ã¾ãŸã¯ç¾åœ¨ã®è¨­å®šã§å†æç”»ã™ã‚‹)
                 startSimulation([]);
                 return;
            }


            selectedAxes.forEach(axis => {
                let formula = '';
                let isRotation = axis.includes('rotation');
                const startVar = isRotation ? `start${axis.substring(8)}` : `start${axis}`;
                
                // --- æ•°å¼ç”Ÿæˆãƒ­ã‚¸ãƒƒã‚¯ ---
                switch(preset) {
                    case 'straight_line':
                        formula = `${startVar} + (time / duration) % 1 * ${valueA}`;
                        break;
                    case 'straight_line_ease':
                        formula = `t = (time / duration) % 1;
t = (t < 0.5 ? t : 1 - t) * 2;
t = t < 0.5 ? 2 * t * t : 1 - pow(-2 * t + 2, 2) / 2;
${startVar} + t * ${valueA}`;
                        break;
                    case 'rotation':
                        formula = `(${startVar} + time * ${valueB}) % 360`;
                        break;
                    case 'swing':
                        formula = `${startVar} + sin(time / duration * 2 * PI) * ${valueB}`;
                        break;
                    case 'linear_acceleration_cap':
                        const acc = 45; 
                        const v0 = 45;  
                        const capTime = 5; 
                        const angleAtCap = v0 * capTime + acc * capTime * capTime / 2;
                        const speedAtCap = v0 + acc * capTime;
                        formula = `a = ${acc};
v0 = ${v0};
time < ${capTime} ?
(${startVar} + v0 * time + a * time * time / 2) % 360
:
(${startVar} + ${angleAtCap} + ${speedAtCap} * (time - ${capTime}) ) % 360`;
                        break;
                    case 'circular_motion_xz':
                        const radius = valueA;
                        if (axis === 'positionX') {
                            formula = `${startVar} + cos(time / duration * 2 * PI) * ${radius}`;
                        } else if (axis === 'positionZ') {
                            formula = `${startVar} + sin(time / duration * 2 * PI) * ${radius}`;
                        } else {
                            formula = `${startVar}`;
                        }
                        break;
                    default:
                        formula = `${startVar}`;
                }
                // --------------------------

                if (formula) {
                    outputFormula += `Set ${axis} to:\n${formula}\n\n`;
                    targetProperties.push({ axis: axis, formula: formula });
                }
            });

            formulaOutput.textContent = outputFormula.trim() || "// è»¸ã‚’é¸æŠã—ã¦ãã ã•ã„";
            startSimulation(targetProperties); // ğŸ‘ˆ é‡è¦ãªä¿®æ­£: å¸¸ã«ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é–‹å§‹/æ›´æ–°
        }

        /**
         * ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—ã‚’é–‹å§‹ã™ã‚‹ (å®Ÿè¡Œãƒ­ã‚¸ãƒƒã‚¯ä¿®æ­£)
         */
        function startSimulation(targetProperties) {
            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãŒæ—¢ã«å‹•ã„ã¦ã„ã‚‹å ´åˆã¯åœæ­¢
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            
            // è»¸ãŒé¸æŠã•ã‚Œã¦ã„ãªã„å ´åˆã¯ã€ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å‹•ã‹ã•ãšåˆæœŸä½ç½®ã«æˆ»ã™
            if (targetProperties.length === 0) {
                 simObject.style.transform = `translate(-50%, -50%) rotateX(${INITIAL_ROT_X}deg) rotateY(${INITIAL_ROT_Y}deg)`;
                 simObject.style.backgroundColor = '#ff6f61';
                 simObject.textContent = 'OBJ';
                 return;
            }


            startTime = Date.now();
            
            const MAX_PIXEL_MOVEMENT = 150; 
            const maxDistance = parseFloat(distanceInput.value) || 100;
            const scaleFactor = maxDistance === 0 ? 0 : MAX_PIXEL_MOVEMENT / maxDistance;

            simObject.style.backgroundColor = targetProperties.some(p => p.axis.includes('rotation')) ? '#4CAF50' : '#ff6f61';
            simObject.textContent = targetProperties.some(p => p.axis.includes('rotation')) ? 'ROT' : 'POS';


            const loop = (timestamp) => {
                const elapsedTime = (timestamp - startTime) / 1000;

                const context = {
                    time: elapsedTime,
                    duration: parseFloat(durationInput.value) || 1,
                    startPositionX: START_POS_X,
                    startPositionY: START_POS_Y,
                    startPositionZ: START_POS_Z,
                    startRotationX: START_ROT_X,
                    startRotationY: START_ROT_Y,
                    startRotationZ: START_ROT_Z,
                    PI: PI,
                };
                
                const results = { x: 0, y: 0, z: 0, rotX: 0, rotY: 0, rotZ: 0 };
                
                targetProperties.forEach(prop => {
                    const newValue = safe_evaluate(prop.formula, context);

                    if (prop.axis === 'positionX') results.x = newValue - START_POS_X;
                    else if (prop.axis === 'positionY') results.y = newValue - START_POS_Y;
                    else if (prop.axis === 'positionZ') results.z = newValue - START_POS_Z; // å¥¥è¡Œãã®ç§»å‹•
                    else if (prop.axis === 'rotationX') results.rotX = newValue;
                    else if (prop.axis === 'rotationY') results.rotY = newValue;
                    else if (prop.axis === 'rotationZ') results.rotZ = newValue;
                });

                // åº§æ¨™ãƒãƒƒãƒ”ãƒ³ã‚° (PositionX: å·¦å³, PositionZ: å¥¥è¡Œã)
                const pixelShiftX = results.x * scaleFactor; 
                const pixelShiftY = results.y * scaleFactor * -1; // PositionYã¯é€šå¸¸ã€Œé«˜ã•ã€ãªã®ã§ã€CSSã®Yè»¸ï¼ˆä¸Šä¸‹ï¼‰ã«ãƒãƒƒãƒ”ãƒ³ã‚°
                const pixelShiftZ = results.z * scaleFactor; // PositionZã¯CSSã®Zè»¸ï¼ˆå¥¥æ‰‹å‰ï¼‰ã«ãƒãƒƒãƒ”ãƒ³ã‚°
                
                // CSS Transformã®é©ç”¨ (é©ç”¨é †åºã‚’æ”¹å–„)
                simObject.style.transform = 
                    // 1. 3Då›è»¢ãŒåˆ†ã‹ã‚‹ã‚ˆã†ã«ã€åˆæœŸã®å‚¾ãã‚’é©ç”¨ (åŸç‚¹ã‚’ä¸­å¿ƒã«)
                    `rotateX(${INITIAL_ROT_X}deg) rotateY(${INITIAL_ROT_Y}deg)` + 
                    // 2. æ•°å¼ã«ã‚ˆã‚‹å›è»¢ã‚’é©ç”¨
                    `rotateX(${results.rotX}deg)` + 
                    `rotateY(${results.rotY}deg)` + 
                    `rotateZ(${results.rotZ}deg)` +
                    // 3. ç§»å‹•ã‚’é©ç”¨ (translate3dã§X/Y/Zã‚’ä¸€åº¦ã«è¨­å®š)
                    `translate3d(calc(-50% + ${pixelShiftX}px), calc(-50% + ${pixelShiftY}px), ${pixelShiftZ}px)`;


                animationFrameId = requestAnimationFrame(loop);
            };

            animationFrameId = requestAnimationFrame(loop);
        }

        // --- èµ·å‹•ãƒ­ã‚¸ãƒƒã‚¯ ---
        const inputs = [presetSelect, durationInput, distanceInput, amplitudeInput];
        inputs.forEach(input => input.addEventListener('input', updateFormula));
        axisCheckboxes.forEach(cb => cb.addEventListener('change', updateFormula));

        // ãƒšãƒ¼ã‚¸ãƒ­ãƒ¼ãƒ‰æ™‚ã«å³åº§ã«å®Ÿè¡Œã‚’é–‹å§‹
        // ã“ã‚ŒãŒãªã„ã¨ã€å…¥åŠ›ã‚„ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ãŒå¤‰æ›´ã•ã‚Œã‚‹ã¾ã§ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãŒé–‹å§‹ã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚
        updateFormula(); 
    </script>
</body>
</html>